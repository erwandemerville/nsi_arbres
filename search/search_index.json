{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Arbres : structures de donn\u00e9es et algorithmes","text":"<p>Bienvenue, ce cours se d\u00e9compose en plusieurs parties :</p> <ul> <li> <p>Arbres : d\u00e9finitions et vocabulaire</p> </li> <li> <p>Parcours d'arbres binaires</p> </li> <li> <p>Type abstrait \"Arbre binaire\"</p> </li> <li> <p>Impl\u00e9mentation des arbres binaires</p> </li> <li> <p>Les arbres binaires de recherche (\u00e0 venir)</p> </li> </ul> <p>Voici \u00e9galement des fiches d'exercices PDF pour vous entra\u00eener :</p> <ul> <li> <p>Exercices - Vocabulaire sur les arbres</p> </li> <li> <p>Exercices - Parcours d'un arbre binaire</p> </li> <li> <p>Exercices - Impl\u00e9mentations d'arbres binaires</p> </li> </ul>  <p>Demerville Erwan</p> <p>Me contacter : demerville.erwan@gmail.com</p>"},{"location":"exercices_abr/","title":"Exercices - Arbres binaires de recherche","text":"<p>Voici 3 arbres binaires :</p>   <p>Exercice 1</p> <ol> <li>Parmi ces arbres, pouvez-vous dire lesquels sont des arbres binaires de recherche ?</li> <li>Quelle est l'ordre des noeuds lors des parcours pr\u00e9fixe, infixe, postfixe du premier arbre ?</li> <li>Quel parcours est particuli\u00e8rement int\u00e9ressant avec les arbres binaire de recherche ? Pourquoi ?</li> </ol>   <p>Exercice 2</p> <p>Dessinez un arbre binaire de recherche :</p> <ol> <li>En ajoutant, en suivant l'ordre, les valeurs suivantes : 14,13,12,11,8,5,4,3,1 Que constatez-vous ?</li> <li>Re-dessinez cet arbre de mani\u00e8re \u00e0 obtenir un arbre \u00e9quilibr\u00e9.</li> <li>Si on ins\u00e8re chaque valeur une par une dans l'arbre, dans quel ordre faut-il les ajouter pour obtenir un arbre \u00e9quilibr\u00e9 ?</li> <li>A votre avis, quelle co\u00fbt algorithmique aura la recherche dans le premier arbre que vous avez dessin\u00e9 ? Dans le deuxi\u00e8me ?</li> </ol>"},{"location":"exercices_parcours/","title":"Exercices - Parcours d'arbres binaires","text":"<p>Info</p> <p>Ces exercices sont \u00e9galement disponibles en format PDF : fiche2_parcours.pdf</p>"},{"location":"exercices_parcours/#exercices-parcours-darbres-binaires","title":"Exercices - Parcours d'arbres binaires","text":"<p>Il existe plusieurs fa\u00e7ons de parcourir un arbre binaire (c'est-\u00e0-dire de visiter les n\u0153uds de l'arbre dans un ordre pr\u00e9cis), et notamment deux types de parcours :</p> <ul> <li>le parcours en largeur d'abord,</li> <li>le parcours en profondeur d'abord.</li> </ul>"},{"location":"exercices_parcours/#parcours-en-profondeur","title":"Parcours en profondeur","text":"<p>En l\u2019occurrence, trois cas particuliers du parcours en profondeur sont \u00e0 conna\u00eetre sur les arbres binaires : le parcours en ordre pr\u00e9fixe, en ordre infixe et en ordre suffixe (ou postfixe).</p> <p>Ces parcours se d\u00e9finissent de mani\u00e8re r\u00e9cursive. Ils consistent \u00e0 traiter la racine de l'arbre et \u00e0 parcourir r\u00e9cursivement les sous-arbres gauche et droit de la racine. Les parcours pr\u00e9fixe, infixe et suffixe se distinguent par l'ordre dans lequel sont effectu\u00e9s ces traitements.</p>"},{"location":"exercices_parcours/#parcours-prefixe-infixe-postfixe","title":"Parcours pr\u00e9fixe, infixe, postfixe","text":"<p>Voici un arbre binaire :</p>   Un arbre binaire   <p>D\u00e9roulement parcours pr\u00e9fixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours pr\u00e9fixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On <code>visite</code> le n\u0153ud racine de l'arbre.</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre droit (s'il est NON vide).</li> </ol>   <p>Exercice 1</p> <p>En suivant le d\u00e9roulement pr\u00e9c\u00e9dent, listez les valeurs des n\u0153uds de l'arbre en figure 1 visit\u00e9s dans l'ordre pr\u00e9fixe.</p>   <p>D\u00e9roulement parcours suffixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours suffixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours suffixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On effectue le <code>parcours suffixe</code> du sous-arbre droit (s'il est NON vide).</li> <li>On <code>visite</code> le n\u0153ud racine de l'arbre.</li> </ol>   <p>Exercice 2</p> <p>En suivant le d\u00e9roulement pr\u00e9c\u00e9dent, listez les valeurs des n\u0153uds de l'arbre en figure 1 visit\u00e9s dans l'ordre suffixe.</p>   <p>D\u00e9roulement parcours infixe</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours infixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours infixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On <code>visite</code> le n\u0153ud racine de l'arbre.</li> <li>On effectue le <code>parcours infixe</code> du sous-arbre droit (s'il est NON vide).</li> </ol>   <p>Exercice 3</p> <p>En suivant le d\u00e9roulement pr\u00e9c\u00e9dent, listez les valeurs des n\u0153uds de l'arbre en figure 1 visit\u00e9s dans l'ordre infixe.</p>   <p>Exercice 4</p> <ol> <li>Redessinez l'arbre en figure 1 en y ajoutant les n\u0153uds vides (not\u00e9s \\(\\emptyset\\)) et les ar\u00eates associ\u00e9es. Vous pouvez les dessiner en pointill\u00e9s.</li> <li>Tracez le contour de l'arbre (en commen\u00e7ant \u00e0 gauche de la racine).</li> <li>Listez les n\u0153uds de l'arbre de trois mani\u00e8re diff\u00e9rentes :<ul> <li>Une premi\u00e8re liste dans laquelle vous ajoutez chaque n\u0153ud lorsque vous passez \u00e0 sa gauche. Quel est l'ordre de parcours (pr\u00e9fixe, infixe, postfixe) ainsi obtenu ?</li> <li>Une seconde liste dans laquelle vous ajoutez chaque n\u0153ud lorsque vous passez \u00e0 sa droite. Quel est l'ordre de parcours (pr\u00e9fixe, infixe, postfixe) ainsi obtenu ?</li> <li>Une troisi\u00e8me liste dans laquelle vous ajoutez chaque n\u0153ud lorsque vous passez en dessous. Quel est l'ordre de parcours (pr\u00e9fixe, infixe, postfixe) ainsi obtenu ?</li> </ul> </li> </ol>"},{"location":"exercices_parcours/#parcours-en-largeur","title":"Parcours en largeur","text":"<p>Le parcours en largeur consiste \u00e0 parcourir un arbre niveau par niveau. Le n\u0153ud de profondeur 0 (ou 1 selon la convention choisie) est d'abord parcouru, puis les n\u0153uds de profondeur 1 (ou 2), et ainsi de suite.  \u00c0 chaque niveau, les n\u0153uds sont parcourus de la gauche vers la droite.</p>  <p>D\u00e9roulement parcours en largeur</p> <p>Le parcours en largeur fonctionne donc de la mani\u00e8re suivante :</p> <ul> <li>On <code>visite</code> le n\u0153ud racine</li> <li>On <code>visite</code> les n\u0153uds fils du n\u0153ud racine (d'abord le fils gauche, puis le fils droit)</li> <li>Puis on <code>visite</code> les n\u0153uds fils du fils gauche du n\u0153ud racine, puis les n\u0153uds fils du fils droit du n\u0153ud racine</li> <li>Et ainsi de suite...</li> </ul>  <p>Par exemple, si l'on parcourt l'arbre suivant en largeur, les n\u0153uds seront visit\u00e9s dans cet ordre : <code>[E, B, G, A, D, F, H, C]</code></p>   <p>Exercice 5</p> <p>Listez les valeurs des n\u0153uds de l'arbre en figure 1 visit\u00e9s lors d'un parcours en largeur.</p>   <p>Exercice 6</p> <p>Si l'on impl\u00e9mentait l'algorithme de parcours en largeur, on aurait besoin d'une structure de donn\u00e9es permettant d'y stocker \u00e0 chaque fois les prochains n\u0153uds \u00e0 visiter (qui contiendrait initialement la racine de l'arbre), de mani\u00e8re \u00e0 ce que le premier n\u0153ud ajout\u00e9 soit le premier n\u0153ud visit\u00e9.</p> <p>\u00c0 votre avis, quelle structure de donn\u00e9es lin\u00e9aire pourrait-on utiliser pour impl\u00e9menter le parcours en largeur ?</p>"},{"location":"exercices_vocabulaire/","title":"Exercices - Vocabulaire sur les arbres","text":"<p>Info</p> <p>Ces exercices sont \u00e9galement disponibles en format PDF : fiche1_vocabulaire.pdf</p>"},{"location":"exercices_vocabulaire/#exercices-vocabulaire-sur-les-arbres","title":"Exercices - Vocabulaire sur les arbres","text":""},{"location":"exercices_vocabulaire/#dessiner-un-arbre","title":"Dessiner un arbre","text":""},{"location":"exercices_vocabulaire/#une-arborescence-de-fichiers","title":"Une arborescence de fichiers","text":"<p>Sur Linux, on peut lister r\u00e9cursivement les r\u00e9pertoires et fichiers du syst\u00e8me \u00e0 l'aide de la commande <code>tree</code>. Voici un exemple d'arborescence obtenue apr\u00e8s ex\u00e9cution de cette commande :</p>   Une arborescence sur Linux   <p>Exercice 1</p> <p>Dessinez un arbre repr\u00e9sentant cette arborescence, en partant de l'arbre suivant :</p>  <ol> <li>Quelle est la taille de cet arbre ?</li> <li>Combien y a t-il d'ar\u00eates dans l'arbre ?</li> <li>Quelles sont les feuilles de l'arbre ?</li> </ol> <p>En consid\u00e9rant que la profondeur de la racine est de 1 :</p> <ol> <li>Quelle est la profondeur du n\u0153ud D5 ?</li> <li>Quelle est la hauteur de l'arbre ?</li> <li>Cet arbre est-il un arbre binaire ? Pourquoi ?</li> </ol>   Correction exercice 1 <ol> <li>La taille est de 11, car il y a 11 noeuds dans l'arbre.</li> <li>En sachant que chaque noeud, \u00e0 l'exception du noeud racine, poss\u00e8de exactement une ar\u00eate le reliant \u00e0 son noeud p\u00e8re, le nombre d'ar\u00eates d'un arbre est toujours \\(taille - 1\\). Ici, le nombre d'ar\u00eates est donc de 11 - 1 = 10.</li> <li>Une feuille est un noeud qui n'a pas de noeuds fils. Ici, les feuilles sont au nombre de 5 : F2.txt, F6, F1.txt, D5, F3.txt.</li> <li>La profondeur du noeud D5, en consid\u00e9rant que la racine a une profondeur de 1, est le nombre de noeuds qui le s\u00e9pare de la racine : Elle est donc ici de 3.</li> <li>La hauteur d'un arbre est la plus grande profondeur des feuilles de l'arbre, ici elle est donc de 4.</li> <li>Dans un arbre binaire, un noeud ne peut avoir qu'un, deux ou trois noeuds fils. Ici, ce n'est pas le cas, l'arbre n'est donc pas un arbre binaire (on dira que c'est un arbre enracin\u00e9).</li> </ol>"},{"location":"exercices_vocabulaire/#arbre-dune-page-html","title":"Arbre d'une page HTML","text":"<p>Voici le code HTML d'une page web :</p> <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\"&gt;\n        &lt;title&gt;Ma superbe page&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Mon super titre&lt;/h1&gt;\n        &lt;p&gt;Mon super paragraphe&lt;/p&gt;\n        &lt;img src=\"mon_image.png\" alt=\"ma superbe image\" /&gt;\n    &lt;/body&gt;\n    &lt;footer&gt;\n        &lt;p&gt;Un pied de page&lt;/p&gt;\n    &lt;/footer&gt;\n&lt;/html&gt;\n</code></pre> <p>L'arbre (appel\u00e9 arbre DOM) repr\u00e9sentant ce code HTML est le suivant :</p>   Arbre DOM d'une page HTML   <p>Exercice 2</p> <p>\u00c0 votre tour, dessinez l'arbre DOM repr\u00e9sentant la page HTML suivante :</p> <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\"&gt;\n        &lt;link href=\"main.css\" rel=\"stylesheet\"&gt;\n        &lt;title&gt;Pok\u00e9mons&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;section&gt;\n            &lt;h1&gt;Types des pok\u00e9mons&lt;/h1&gt;\n            &lt;ul&gt;\n                &lt;li&gt;FEU&lt;/li&gt;\n                &lt;li&gt;FOUDRE&lt;/li&gt;\n                &lt;li&gt;EAU&lt;/li&gt;\n                &lt;li&gt;HERBE&lt;/li&gt;\n                &lt;li&gt;NORMAL&lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/section&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ol> <li>Quelle est la taille de l'arbre obtenu ?</li> <li>Quelle est la hauteur de l'arbre obtenu :</li> <li>Si la profondeur de la racine est de 0 ?</li> <li>Si la profondeur de la racine est de 1 ?</li> <li>Quels types d'\u00e9l\u00e9ments repr\u00e9sentent les feuilles de l'arbre ?</li> <li>Si les n\u0153uds de l'arbre \u00e9taient des instances d'une classe <code>Noeud</code> caract\u00e9ris\u00e9s par une \u00e9tiquette (<code>html</code>, <code>body</code>, etc) et des donn\u00e9es, quelles pourraient \u00eatre ces donn\u00e9es ? (voir la balise <code>meta</code> ou <code>link</code> du code ci-dessus.)</li> </ol>   Correction exercice 2 <p>Voici l'arbre obtenu \u00e0 partir de ce code HTML : </p> <ol> <li>La taille est de 21 car il y a 21 noeuds* dans l'arbre.</li> <li>La hauteur est la profondeur des feuilles les plus \u00e9loign\u00e9es de la racine, elle est de 5 si la profondeur de la racine vaut 0, et de 6 si la profondeur de la racine vaut 1.</li> <li>Les feuilles de l'arbre repr\u00e9sentent :<ul> <li>le texte brut contenu \u00e0 l'int\u00e9rieur des balises ouvrantes et fermantes,</li> <li>Les balises autofermantes (comme la balise <code>meta</code>, <code>link</code>, etc.)</li> </ul> </li> <li>Pour repr\u00e9senter correctement une page web, on aurait besoin d'un objet permettant de stocker les attributs associ\u00e9s aux balises. Par exemple ici, les attributs de la balise <code>link</code> sont <code>href</code> (qui vaut <code>main.css</code>, un fichier CSS) et <code>rel</code> (qui vaut <code>stylesheet</code>, indiquant que la ressource est une feuille de style CSS). En Python, on pourrait imaginer par exemple de stocker ces attributs dans un dictionnaire.</li> </ol>"},{"location":"exercices_vocabulaire/#arbre-dune-expression-arithmetique","title":"Arbre d'une expression arithm\u00e9tique","text":"<p>Voici un arbre binaire repr\u00e9sentant l'expression arithm\u00e9tique \\((6 + 9) / 3\\) :</p>   Arbre d'une expression arithm\u00e9tique   <p>Exercice 3</p> <p>\u00c0 votre tour, dessinez l'arbre binaire correspondant \u00e0 l'expression \\(\\frac{5*8}{30-(8*3)}\\).</p> <ol> <li>Pour quels op\u00e9rateurs le positionnement (gauche, droit) des op\u00e9randes a une importance ? Pourquoi ?</li> <li>Quelle est la taille de l'arbre obtenu ?</li> <li>Quelles sont les feuilles de l'arbre ? Quelle remarque pouvez-vous faire ?</li> </ol> <p> En consid\u00e9rant que la profondeur de la racine est de 0 :</p> <ol> <li>Quelle est la profondeur des feuilles les moins \u00e9loign\u00e9es de la racine ?</li> <li>Quelle est la hauteur de l'arbre ?</li> </ol>   Correction exercice 3 <p>Voici l'arbre obtenu : </p> <ol> <li>Il a une importance pour la soustraction et la division. On n'obtient par exemple pas le m\u00eame r\u00e9sultat en faisant \\(30 - 24\\) et \\(24 - 30\\). Ici, on a en effet d\u00e9cid\u00e9 que le sous-arbre gauche repr\u00e9sentait l'op\u00e9rande gauche, et le sous-arbre droit l'op\u00e9rande droite.</li> <li>L'arbre obtenu est de taille 9 (car il y a 9 noeuds).</li> <li>Les feuilles de cet arbre sont <code>5</code>, <code>8</code>, <code>30</code>, <code>8</code> et <code>3</code>. Toutes les feuilles de l'arbre contiennent les valeurs num\u00e9riques, tandis que les autres noeuds contiennent les op\u00e9rateurs.</li> <li>Les feuilles de l'arbre les moins \u00e9loign\u00e9es de la racine sont de profondeur 2 (en prenant 0 comme profondeur pour la racine.)</li> <li>La hauteur de cet arbre est de 3.</li> </ol>"},{"location":"exercices_vocabulaire/#encadrement-de-la-hauteur","title":"Encadrement de la hauteur","text":"<p>Pour l'exercice suivant, on consid\u00e9rera que la profondeur de la racine d'un arbre est de 1. Voici deux arbres binaires :</p>   Deux arbres binaires   <p>Exercice 4</p> <ol> <li>Parmi ces deux arbres, lequel est un arbre filiforme ? Un arbre complet ?</li> <li>\u00c0 quelle autre structure de donn\u00e9es s'apparente un arbre filiforme ? Pourquoi ?</li> <li>Quelle est la taille de ces deux arbres ?</li> <li>Quelles sont toutes les hauteurs possibles pour une taille \\(n = 5\\) ?</li> <li>\u00c9tablissez une relation entre la taille d'un arbre not\u00e9e \\(n\\) et la hauteur de cet arbre not\u00e9e \\(h\\), dans le cas o\u00f9 l'arbre est filiforme.</li> <li> <ol> <li>Compl\u00e9tez l'arbre B de mani\u00e8re \u00e0 obtenir un arbre parfait.</li> <li>Combien y a t-il de n\u0153uds de profondeur 1, 2 et 3  dans cet arbre parfait ? En d\u00e9duire combien il y aurait de noeuds de profondeur 4 et 5 dans un arbre parfait de hauteur 5 (vous pouvez dessiner un tableau).</li> <li>\u00c9tablissez une relation entre le nombre de n\u0153uds \u00e0 une certaine profondeur, not\u00e9 \\(n_{p}\\), en fonction de cette profondeur, not\u00e9e \\(p\\).</li> <li>En d\u00e9duire une expression calculant la taille \\(n\\) (nombre de n\u0153uds) d'un arbre parfait en fonction de sa hauteur \\(h\\).</li> </ol> </li> <li>Enfin, proposez d'abord un encadrement de la taille d'un arbre binaire not\u00e9e \\(n\\) en fonction de la hauteur not\u00e9e \\(h\\) (en utilisant vos r\u00e9ponses aux questions <code>5.</code> et <code>6.d.</code>). \u00c0 partir de l'encadrement pr\u00e9c\u00e9dent, d\u00e9duire un encadrement de la hauteur d'un arbre binaire en fonction de sa taille.</li> </ol>   Correction exercice 4 <ol> <li>L'arbre A est un arbre filiforme. L'arbre B est un arbre complet.</li> <li>Un arbre filiforme s'apparente \u00e0 une liste cha\u00een\u00e9e. En effet, chaque noeud pointe vers un seul autre noeud de l'arbre. On verra dans le cours sur les arbres binaires de recherche que la recherche et l'insertion dans un arbre filiforme n'est pas int\u00e9ressante (car m\u00eame co\u00fbt que sur une liste cha\u00een\u00e9e).</li> <li>Ces deux arbres sont de taille \\(n = 5\\).</li> <li>Un arbre de taille 5 peut \u00eatre de hauteur minimale 3 (arbre B) et de hauteur maximale 5 (arbre A) avec une profondeur 1 pour le noeud racine. Les diff\u00e9rentes hauteurs possibles sont donc 3, 4 et 5.</li> <li>Dans le cas o\u00f9 l'arbre est filiforme, la hauteur d'un arbre est \u00e9gale \u00e0 son nombre de noeuds (= sa taille). On peut donc \u00e9crire que \\(n = h\\).</li> <li> <p>a. Voici l'arbre obtenu (il suffit d'ajouter deux noeuds dans le niveau le plus bas de l'arbre pour que celui-ci soit rempli et que l'arbre devienne un arbre parfait) :  b. En notant \\(p\\) la profondeur et \\(n_{p}\\) le nombre de noeuds de profondeur \\(p\\) :  c. Du tableau pr\u00e9c\u00e9dent, on peut d\u00e9duire la relation \\(n_{p} = 2^{p-1}\\). d. Finalement, la taille not\u00e9e \\(n\\) d'un arbre parfait en fonction de sa hauteur not\u00e9e \\(h\\) peut se calculer de la mani\u00e8re suivante : \\(n = 2^{0} + 2^{1} + [...] + 2^{h-1} = 2^{h} - 1\\)</p> </li> <li> <p>On a pr\u00e9c\u00e9demment d\u00e9termin\u00e9 la taille minimale d'un arbre binaire en fonction de sa hauteur : \\(n_{min} = h\\) (cas de l'arbre filiforme) On a \u00e9galement determin\u00e9 la taille maximale d'un arbre binaire en fonction de sa hauteur : \\(n_{max} = 2^{h} - 1\\) (cas de l'arbre parfait) On peut donc en d\u00e9duire un encadrement de la taille d'un arbre binaire de fa\u00e7on g\u00e9n\u00e9rale, avec pour profondeur racine 1 : \\(n_{min} \\leq n \\leq n_{max}\\) \\(h \\leq n \\leq 2^{h} - 1\\) \u00c0 partir de l'encadrement pr\u00e9c\u00e9dent, on peut retrouver l'encadrement de la hauteur \\(h\\) : \\(\\lceil log_{2}(n+1) \\rceil \\leq h \\leq n\\)</p> </li> </ol>"},{"location":"exercices_vocabulaire/#denombrement-darbres-binaires","title":"D\u00e9nombrement d'arbres binaires","text":"<p>Exercice 5</p> <p>Dessinez et d\u00e9nombrez tous les arbres binaires possibles :</p> <ul> <li>pour une taille \\(n = 1\\),</li> <li>pour une taille \\(n = 2\\),</li> <li>pour une taille \\(n = 3\\),</li> <li>pour une taille \\(n = 4\\)</li> </ul> <p>Sans les dessiner et en vous aidant des r\u00e9ponses pr\u00e9c\u00e9dentes, d\u00e9terminez le nombre d'arbres de taille \\(n = 5\\).</p>   Indice 1 exercice 5 <p>Vous pouvez d\u00e9nombrer les arbres de taille \\(n = 5\\) en faisant la somme des arbres dont les noeuds sont r\u00e9partis de la mani\u00e8re suivante :</p> <ul> <li>1 noeud racine et 4 noeuds \u00e0 droite</li> <li>1 noeud racine et 4 noeuds \u00e0 gauche</li> <li>1 noeud racine, 3 noeuds \u00e0 gauche et 1 noeud \u00e0 droite</li> <li>1 noeud racine, 1 noeud \u00e0 gauche et 3 noeud \u00e0 droite</li> <li>1 noeud racine, 2 noeuds \u00e0 gauche et 2 noeuds \u00e0 droite</li> </ul>  <p>En comptant le nombre de possibilit\u00e9s pour ces 5 cas, vous obtiendrez le nombre total d'arbres de taille \\(n = 5\\).</p>   Indice 2 exercice 5 <p>Le nombre d'arbres d'une taille \\(n\\) donn\u00e9e peut \u00eatre calcul\u00e9 avec le nombre de Catalan, voir page Wikipedia pour plus d'informations. (Bien s\u00fbr, ce n'est pas au programme.)</p> <p>Donc, pour une taille \\(n = 5\\) : \\(C_{5} = \\frac{(2n)!}{(n+1)!n!} = \\frac{10!}{6!*5!} = \\frac{5040}{120} = 42\\)</p> <p>Il y a donc 42 arbres de taille 5.</p>"},{"location":"implementation_arbres/","title":"Impl\u00e9mentation d'un arbre binaire","text":"<p>Il y a de nombreuses mani\u00e8res d'impl\u00e9menter un arbre binaire.</p> <p>Dans cette partie, on proposera une mani\u00e8re parmi d'autres d'impl\u00e9menter cette structure de donn\u00e9es. Pour vous entra\u00eener sur d'autres impl\u00e9mentations, voir la partie exercices.</p> <p>En langage Python, on ne peut pas avoir plusieurs constructeurs dans une classe. On aura donc un seul constucteur pouvant \u00eatre appel\u00e9 de deux fa\u00e7ons diff\u00e9rentes :</p> <ul> <li><code>Arbre()</code> : cr\u00e9ation d'un arbre binaire vide, les attributs <code>racine</code>, <code>gauche</code> et <code>droite</code> seront automatiquement affect\u00e9s \u00e0 <code>None</code>.</li> <li><code>Arbre(racine, gauche, droite)</code> : cr\u00e9ation d'un arbre binaire non vide, dont la <code>racine</code> est la valeur (l'\u00e9tiquette) du noeud racine, et <code>gauche</code> et <code>droite</code> sont \u00e9galement de type <code>Arbre</code>.</li> </ul> <p>Note : Une feuille est donc une instance  de <code>Arbre</code> dont le sous-arbre gauche et le sous-arbre droit sont des arbres vides.</p>  <p>\u00c0 t\u00e9l\u00e9charger</p> <p>R\u00e9cup\u00e9rez les fichiers suivants :</p> <ul> <li>arbre_binaire.py - Classe <code>Arbre</code> \u00e0 compl\u00e9ter repr\u00e9sentant un arbre binaire.</li> <li>dessin.py - Quelques fonctions annexes utilis\u00e9es pour dessiner un arbre avec le module <code>Graphviz</code>. (Vous n'avez pas besoin d'ouvrir ou de modifier ce fichier.)</li> </ul> <p>Si vous utilisez les machines du lyc\u00e9e:</p> <ul> <li>windows_graphviz.zip - D\u00e9compressez l'archive dans le r\u00e9pertoire o\u00f9 se trouvent vos fichiers Python. Vous devez avoir <code>arbre_binaire.py</code>, <code>dessin.py</code> et un dossier <code>Graphviz</code> au m\u00eame endroit.Contient les ex\u00e9cutables de Graphviz.</li> </ul>   Installation de Graphviz sur votre machine personnelle <p>Pour utiliser la fonction <code>dessiner</code>, le module <code>Graphviz</code> et les ex\u00e9cutables associ\u00e9s doivent \u00eatre install\u00e9s sur votre machine. Voici comment proc\u00e9der.</p> <p>\u00c9tape 1 - Installer le module Graphviz</p> <p>M\u00e9thode 1 :</p> <p>Dans Thonny, allez dans l'onglet \"Outils\", puis \"G\u00e9rer les paquets\". Recherchez \"graphviz\", puis cliquez sur le bouton Installer.</p> <p>M\u00e9thode 2 :</p> <p>Ouvrez l'invite de commande Windows (ou le terminal si vous utilisez Linux), puis ex\u00e9cutez simplement la commande suivante :</p> <pre><code>pip install graphviz\n</code></pre> <p>\u00c9tape 2 - Installer les ex\u00e9cutables</p> <p>Si vous \u00eates sur Windows, cliquez ici puis t\u00e9l\u00e9chargez et installez la derni\u00e8re version de Graphviz (choisissez l'<code>EXE Installer</code> correspondant \u00e0 la version de votre syst\u00e8me d'exploitation, 32 bits ou 64 bits. Si vous avez un doute, choisissez la version 32 bits ou lisez cet article pour conna\u00eetre la version de votre syst\u00e8me.)</p> <p>Si vous \u00eates sur Linux, cliquez ici puis installez le paquet <code>graphviz</code> en ex\u00e9cutant dans le terminal la commande associ\u00e9e \u00e0 votre distribution (Ubuntu, Fedora, etc.).</p> <p>Si vous \u00eates sur macOS, cliquez ici puis ex\u00e9cutez l'une des commandes indiqu\u00e9es.</p>"},{"location":"implementation_arbres/#methodes-de-la-classe","title":"M\u00e9thodes de la classe","text":"<p>Int\u00e9ressons-nous d'abord aux m\u00e9thodes de notre classe, de mani\u00e8re \u00e0 d\u00e9finir les op\u00e9rations de base pouvant \u00eatre effectu\u00e9es sur notre arbre.</p> <pre><code>''' Classe impl\u00e9mentant un Arbre Binaire. '''\n\nclass Arbre:\n    def __init__(self, valeur=None, gauche=None, droite=None):\n        ''' Cr\u00e9e un nouvel arbre binaire.\n        :param valeur: (int|str) La valeur du noeud racine, soit un entier, soit une cha\u00eene de caract\u00e8res\n        :param gauche: (Arbre) Le sous-arbre binaire gauche (None pour arbre binaire vide)\n        :param droite: (Arbre) Le sous-arbre binaire droit (None pour arbre binaire vide)\n        :CU: Si valeur est \u00e0 None, gauche et droite doivent \u00eatre \u00e9galement \u00e0 None (cas de l'arbre vide),\n        sinon, gauche et droite doivent \u00eatre de type Arbre. '''\n\n        assert (valeur == None and gauche == None and droite == None) or \\\n               (type(valeur) in (int, str) and type(gauche) == Arbre and type(droite) == Arbre)\n\n        self.v = valeur\n        self.g = gauche\n        self.d = droite\n\n    def est_vide(self):\n        ''' Renvoie True si l'arbre binaire est vide, False s'il ne l'est pas. '''\n        pass\n\n    def racine(self):\n        ''' Renvoie le Noeud racine de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\n        pass\n\n    def valeur_racine(self):\n        ''' Renvoie la valeur de la racine de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide'''\n        pass\n\n    def gauche(self):\n        ''' Renvoie le sous-arbre gauche de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide'''\n        pass\n\n    def droite(self):\n        ''' Renvoie le sous-arbre droit de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide'''\n        pass\n\n    def est_feuille(self):\n        ''' Renvoie True si l'arbre binaire est une feuille, False s'il ne l'est pas.\n        :CU: L'arbre n'est PAS vide'''\n        pass\n\n# Les fonctions d'interface (vous pouvez les utiliser au lieu des m\u00e9thodes de classe, au choix), \u00e0 compl\u00e9ter :\n\ndef valeur_racine(ab: Arbre) -&gt; 'int|str':\n    pass\n\ndef gauche(ab: Arbre) -&gt; Arbre:\n    pass\n\ndef droite(ab: Arbre) -&gt; Arbre:\n    pass\n\ndef est_vide(ab: Arbre) -&gt; bool:\n    pass\n\ndef est_feuille(ab: Arbre) -&gt; bool:\n    pass\n</code></pre>  <p>Important</p> <p>Dans cette impl\u00e9mentation, on n'utilise pas de classe <code>Noeud</code> pour repr\u00e9senter les noeuds de l'arbre (ce qui diff\u00e8re du type abstrait). On consid\u00e8re que le noeud racine d'un arbre est l'arbre lui-m\u00eame. La m\u00e9thode nomm\u00e9e <code>racine</code> renverra donc simplement l'adresse de l'instance de la classe <code>Arbre</code>.</p>   <p>\u00c0 faire</p> <p>Compl\u00e9tez le corps de chaque m\u00e9thode de la classe <code>Arbre</code>.</p>   Solution <pre><code>''' Classe impl\u00e9mentant un Arbre Binaire. '''\n\nclass Arbre:\n    def __init__(self, valeur=None, gauche=None, droite=None):\n        ''' Cr\u00e9e un nouvel arbre binaire.\n        :param valeur: (int|str) La valeur du noeud racine, soit un entier, soit une cha\u00eene de caract\u00e8res\n        :param gauche: (Arbre) Le sous-arbre binaire gauche (None pour arbre binaire vide)\n        :param droite: (Arbre) Le sous-arbre binaire droit (None pour arbre binaire vide)\n        :CU: Si valeur est \u00e0 None, gauche et droite doivent \u00eatre \u00e9galement \u00e0 None (cas de l'arbre vide),\n        sinon, gauche et droite doivent \u00eatre de type Arbre. '''\n\n        assert (valeur == None and gauche == None and droite == None) or \\\n               (type(valeur) in (int, str) and type(gauche) == Arbre and type(droite) == Arbre)\n\n        self.v = valeur\n        self.g = gauche\n        self.d = droite\n\n    def est_vide(self):\n        ''' Renvoie True si l'arbre binaire est vide, False s'il ne l'est pas. '''\n        return self.v == None\n\n    def racine(self):\n        ''' Renvoie le Noeud racine de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide '''\n        return self\n\n    def valeur_racine(self):\n        ''' Renvoie la valeur de la racine de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide'''\n        return self.v\n\n    def gauche(self):\n        ''' Renvoie le sous-arbre gauche de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide'''\n        return self.g\n\n    def droite(self):\n        ''' Renvoie le sous-arbre droit de l'arbre binaire.\n        :CU: L'arbre n'est PAS vide'''\n        return self.d\n\n    def est_feuille(self):\n        ''' Renvoie True si l'arbre binaire est une feuille, False s'il ne l'est pas.\n        :CU: L'arbre n'est PAS vide'''\n        return self.gauche().est_vide() and self.droite().est_vide()\n\n# Les fonctions d'interface (vous pouvez les utiliser au lieu des m\u00e9thodes de classe, au choix) :\n\ndef valeur_racine(ab: Arbre) -&gt; 'int|str':\n    return ab.v\n\ndef gauche(ab: Arbre) -&gt; Arbre:\n    return ab.g\n\ndef droite(ab: Arbre) -&gt; Arbre:\n    return ab.d\n\ndef est_vide(ab: Arbre) -&gt; bool:\n    return est_vide(ab)\n\ndef est_feuille(ab: Arbre) -&gt; bool:\n    return est_feuille(ab)\n</code></pre>"},{"location":"implementation_arbres/#creation-dun-nouvel-arbre","title":"Cr\u00e9ation d'un nouvel arbre","text":"<p>Essayons de cr\u00e9er l'arbre suivant en utilisant notre classe <code>Arbre</code> :</p>   Arbre binaire cr\u00e9\u00e9 avec la classe Arbre   <p>Note</p> <p>L'affichage avec <code>Graphviz</code> ne permettant pas toujours de bien distinguer visuellement les sous-arbres gauches des sous-arbres droits, on a ajout\u00e9 l'information <code>G</code> ou <code>D</code> sur chaque ar\u00eate, indiquant respectivement qu'il s'agit du sous-arbre gauche ou du sous-arbre droit.</p>  <p>Voici une instruction permettant de cr\u00e9er cet arbre \u00e0 l'aide de notre classe <code>Arbre</code> et de le stocker dans une variable <code>a</code> :</p> <pre><code>    ab = Arbre('C',\n              Arbre('A',\n                    Arbre(),\n                    Arbre('H',\n                          Arbre('D', Arbre(), Arbre()),\n                          Arbre('F', Arbre(), Arbre())\n                          )\n                    ),\n              Arbre('B',\n                    Arbre('G', Arbre(), Arbre()),\n                    Arbre('E', Arbre(), Arbre())\n                    )\n              )\n</code></pre> <p>Bien s\u00fbr, on aurait pu l'\u00e9crire sur une seule ligne :</p> <pre><code>    ab = Arbre('C', Arbre('A', Arbre(), Arbre('H', Arbre('D', Arbre(), Arbre()), Arbre('F', Arbre(), Arbre()))), Arbre('B', Arbre('G', Arbre(), Arbre()), Arbre('E', Arbre(), Arbre())))\n</code></pre> <p>On aurait \u00e9galement pu cr\u00e9er plusieurs variables de mani\u00e8re \u00e0 d\u00e9composer l'arbre :</p> <pre><code>    # Cr\u00e9ation des feuilles\n    fd = Arbre('D', Arbre(), Arbre())\n    ff = Arbre('F', Arbre(), Arbre())\n    fg = Arbre('G', Arbre(), Arbre())\n    fe = Arbre('E', Arbre(), Arbre())\n    # Cr\u00e9ation des sous-arbres\n    sah = Arbre('H', fd, ff)\n    sab = Arbre('B', fg, fe)\n    saa = Arbre('A', Arbre(), sah)\n    # Cr\u00e9ation de l'arbre final\n    ab = Arbre('C', saa, sab)\n</code></pre> <p>Enfin, pour dessiner cet arbre, on peut utiliser la fonction dessiner import\u00e9e depuis <code>dessin.py</code> :</p> <pre><code>    dessiner(ab)\n</code></pre> <p>Si l'on souhaite acc\u00e9der par exemple au noeud ayant pour valeur B, qui est \u00e9quivalent \u00e0 l'arbre dont <code>valeur_racine() == 'B'</code>, on utilisera l'instruction :</p> <p><pre><code>    droite(ab).racine()\n</code></pre> ou simplement</p> <pre><code>    droite(ab)\n</code></pre> <p>et si on veut r\u00e9cup\u00e9rer la valeur de ce noeud :</p> <pre><code>    droite(ab).valeur_racine()\n</code></pre>  <p>\u00c0 faire</p> <p>Comment r\u00e9cup\u00e9rer la feuille ayant pour valeur D ?</p>   Solution <p><pre><code>    gauche(ab).droite().gauche().racine()\n</code></pre> ou simplement</p> <pre><code>    gauche(ab).droite().gauche()\n</code></pre> <p>et pour r\u00e9cup\u00e9rer la valeur qu'elle contient :</p> <pre><code>    gauche(ab).droite().gauche().valeur_racine()\n</code></pre>"},{"location":"implementation_arbres/#quelques-mesures-sur-les-arbres","title":"Quelques mesures sur les arbres","text":"<p>Important</p> <p>Pour les mesures suivantes, on consid\u00e8rera que la profondeur du noeud racine est de 0. Ainsi, on consid\u00e8rera que la hauteur de l'arbre vide est de -1. Il s'agit d'un choix arbitraire, on aurait tr\u00e8s bien pu choisir une profondeur de 1 pour le noeud racine (auquel cas l'arbre vide serait de hauteur 0).</p>  <p>On rappelle que pour \u00e9crire des fonctions de mani\u00e8re r\u00e9cursive, vous devez toujours distinguer :</p> <ul> <li>au moins un cas de base (condition d'arr\u00eat), qui ici peut \u00eatre par exemple le cas o\u00f9 l'arbre est vide ou encore le cas o\u00f9 l'arbre est une feuille. Un cas de base est un cas non r\u00e9cursif, pour lequel la valeur renvoy\u00e9e par la fonction est directement d\u00e9finie.</li> <li>au moins un cas g\u00e9n\u00e9ral, ou cas r\u00e9cursif, c'est-\u00e0-dire un cas dans lequel la fonction est appel\u00e9e r\u00e9cursivement et o\u00f9 le r\u00e9sultat renvoy\u00e9 est calcul\u00e9 en utilisant le r\u00e9sultat du (ou des) appel(s) r\u00e9cursif(s). \u00c0 chaque appel r\u00e9cursif, la valeur d'au moins un des param\u00e8tres de la fonction doit changer, de mani\u00e8re \u00e0 converger vers le cas de base.</li> </ul>  <p>\u00c0 faire</p> <p>Compl\u00e9tez les fonctions <code>taille</code>, <code>hauteur</code>, <code>nb_feuilles</code> et <code>est_present</code>. Ces fonctions doivent \u00eatre \u00e9crites de mani\u00e8re r\u00e9cursive.</p>   Indice pour la fonction <code>taille</code> <p>Pour \u00e9crire cette fonction, qui doit fonctionner autant sur un arbre vide que sur un arbre non vide, il convient d'abord de d\u00e9terminer un cas de base, c'est-\u00e0-dire un cas non r\u00e9cursif de mani\u00e8re \u00e0 ce que l'algorithme s'arr\u00eate \u00e0 un moment donn\u00e9. Sur quel type d'arbres la fonction <code>taille</code> renverra toujours la m\u00eame valeur ?</p> <ul> <li>Si l'on cherche la taille d'un arbre vide, on obtiendra toujours 0 car un arbre vide ne contient pas de noeuds. C'est donc l\u00e0 notre cas de base.</li> </ul> <p>Ensuite, il faut d\u00e9termine un cas g\u00e9n\u00e9ral, c'est-\u00e0-dire un cas o\u00f9 l'on effectue un ou plusieurs appels r\u00e9cursifs \u00e0 <code>taille</code>.</p> <ul> <li>Si l'on cherche la taille d'un arbre non vide, c'est-\u00e0-dire d'un arbre constitu\u00e9 d'un noeud racine, d'un sous-arbre gauche et d'un sous-arbre droit, on peut alors \u00e9tablir que la taille de l'arbre correspond \u00e0 1 (on compte le noeud racine) + la taille du sous-arbre gauche + la taille du sous-arbre droit.Au fur et \u00e0 mesure des appels r\u00e9cursifs, on convergera vers le cas o\u00f9 l'arbre est vide, et donc la fonction finira par se terminer.</li> </ul> <p>Maintenant que l'on a d\u00e9termin\u00e9 ces deux cas en fran\u00e7ais, il ne reste plus qu'\u00e0 les retranscrire en Python.</p>   Indice pour la fonction <code>hauteur</code> <p>Cette fonction est assez proche de la fonction <code>taille</code>. On doit pouvoir d\u00e9terminer la hauteur d'un arbre vide ou non.</p> <p>La profondeur du noeud racine est de 0.</p> <ul> <li>On consid\u00e8rera que la hauteur d'un arbre vide est toujours de -1, ce sera donc le cas de base.</li> <li>Pour le cas g\u00e9n\u00e9ral (arbre non vide), il faut compter la racine, donc ajouter 1 \u00e0 la hauteur de l'arbre, puis y ajouter la plus grande hauteur entre celle du sous-arbre gauche et celle du sous-arbre droit (appels r\u00e9cursifs).</li> </ul> <p>Note : La fonction Python <code>max</code> permet de d\u00e9terminer la plus grande valeur enti\u00e8re parmi plusieurs valeurs.</p>   Solutions <pre><code>def taille(ab: Arbre) -&gt; int:\n''' Renvoie la taille d'un arbre. '''\n\nif ab.est_vide():\n    return 0\nelse:\n    return 1 + taille(gauche(ab)) + taille(droite(ab))\n\ndef hauteur(ab: Arbre) -&gt; int:\n''' Renvoie la hauteur d'un arbre. '''\n\n    if ab.est_vide():\n        return -1\n    else:\n        return 1 + max(hauteur(gauche(ab)), hauteur(droite(ab)))\n\ndef nb_feuilles(ab: Arbre) -&gt; int:\n    ''' Renvoie le nombre de feuilles que contient un arbre binaire. '''\n\n    if ab.est_vide():\n        return 0\n    elif ab.est_feuille():\n        return 1\n    else:\n        return nb_feuilles(gauche(ab)) + nb_feuilles(droite(ab))\n\ndef est_present(ab: Arbre, el: int|str) -&gt; bool:\n    ''' Renvoie True si un noeud contenant l'\u00e9l\u00e9ment el est pr\u00e9sent dans l'arbre, False sinon. '''\n\n    if ab.est_vide():\n        return False\n    elif ab.valeur_racine() == el:\n        return True\n    else:\n        return est_present(gauche(ab)) or est_present(droite(ab))\n</code></pre>"},{"location":"implementation_arbres/#parcours-darbres","title":"Parcours d'arbres","text":""},{"location":"implementation_arbres/#parcours-en-profondeur","title":"Parcours en profondeur","text":"<p>On rappelle le d\u00e9roulement des parcours pr\u00e9fixe, infixe et suffixe (ou postfixe). Dans notre impl\u00e9mentation, on se contentera d'afficher les noeuds visit\u00e9s :</p>  <p>D\u00e9roulement parcours pr\u00e9fixe</p> <p>Pr\u00e9condition : L'arbre peut \u00eatre vide Le <code>parcours_pr\u00e9fixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On <code>affiche</code> le n\u0153ud racine de l'arbre.</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre droit (s'il est NON vide).</li> </ol>   <p>D\u00e9roulement parcours suffixe</p> <p>Pr\u00e9condition : L'arbre peut \u00eatre vide Le <code>parcours_suffixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours suffixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On effectue le <code>parcours suffixe</code> du sous-arbre droit (s'il est NON vide).</li> <li>On <code>affiche</code> le n\u0153ud racine de l'arbre.</li> </ol>   <p>D\u00e9roulement parcours infixe</p> <p>Pr\u00e9condition : L'arbre peut \u00eatre vide Le <code>parcours_infixe</code> se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours infixe</code> du sous-arbre gauche (s'il est NON vide).</li> <li>On <code>affiche</code> le n\u0153ud racine de l'arbre.</li> <li>On effectue le <code>parcours infixe</code> du sous-arbre droit (s'il est NON vide).</li> </ol>   <p>\u00c0 faire</p> <p>Impl\u00e9mentez les algorithmes de parcours en profondeur pr\u00e9fixe, infixe et postfixe de mani\u00e8re r\u00e9cursive.</p>   Solution <p>\u00c0 venir...</p>"},{"location":"implementation_arbres/#parcours-en-largeur","title":"Parcours en largeur","text":"<p>Contrairement aux algorithmes de parcours en profondeur, on impl\u00e9mentera le parcours en largeur de mani\u00e8re it\u00e9rative et non r\u00e9cursive.</p> <p>On utilisera une structure de file pour stocker les noeuds \u00e0 visiter, qu'on choisira de repr\u00e9senter par une liste Python. Les op\u00e9rations sur cette file sont les suivantes :</p> <ul> <li><code>file.pop(0)</code> : d\u00e9filer (r\u00e9cup\u00e9rer le premier \u00e9l\u00e9ment de la file et le retirer de la file),</li> <li><code>file.append(element)</code> : enfiler (ajouter un \u00e9l\u00e9ment \u00e0 la fin de la file).</li> </ul> <p>Voici le d\u00e9roulement du parcours en largeur :</p>  <p>D\u00e9roulement parcours en largeur</p> <p>Pr\u00e9condition : L'arbre n'est pas vide Le <code>parcours_en_largeur</code> se d\u00e9roule comme suit :</p> <ol> <li>On <code>cr\u00e9e</code> une nouvelle file vide.</li> <li>On <code>enfile</code> dedans le noeud racine de l'arbre (qui est, dans notre impl\u00e9mentation, \u00e9quivalent \u00e0 l'arbre lui-m\u00eame).</li> <li>TANT QUE la file n'est PAS vide :<ol> <li>On <code>d\u00e9file</code> la file et on stocke le noeud r\u00e9cup\u00e9r\u00e9 dans une variable.</li> <li>On <code>affiche</code> la valeur du noeud r\u00e9cup\u00e9r\u00e9.</li> <li>Si le sous-arbre gauche \u00e0 ce noeud n'est PAS vide, on l'<code>enfile</code> dans la file.</li> <li>Si le sous-arbre droit \u00e0 ce noeud n'est PAS vide, on l'<code>enfile</code> dans la file.</li> </ol> </li> </ol>   <p>\u00c0 faire</p> <p>Impl\u00e9mentez l'algorithme de parcours en largeur.</p>   Solution <p>\u00c0 venir...</p>"},{"location":"implementations_arbres/","title":"Exercices - Impl\u00e9mentations d'arbres binaires et ABR","text":"<p>Important</p> <p>Cette section est en cours de construction. De nouveaux sujets ainsi que les corrections des sujets propos\u00e9s y seront ajout\u00e9s prochainement.</p>"},{"location":"implementations_arbres/#sujets-de-bac-sur-les-arbres","title":"Sujets de bac sur les arbres","text":""},{"location":"implementations_arbres/#sur-les-arbres-binaires","title":"Sur les arbres binaires","text":"<p>Voici quelques sujets pour vous entra\u00eener sur les arbres binaires :</p>"},{"location":"implementations_arbres/#implementations-avec-un-dictionnaire","title":"Impl\u00e9mentations avec un dictionnaire","text":"<ul> <li>Extrait J1G11</li> <li>Extrait J1AS1</li> </ul>"},{"location":"implementations_arbres/#implementation-avec-une-classe-noeud","title":"Impl\u00e9mentation avec une classe Noeud","text":"<ul> <li>Extrait J2AS1</li> </ul>"},{"location":"implementations_arbres/#autres-sujets","title":"Autres sujets","text":"<ul> <li>Extrait Nouvelle-Caledonie 2022</li> </ul>"},{"location":"implementations_arbres/#sur-les-arbres-binaires-de-recherche","title":"Sur les arbres binaires de recherche","text":"<p>\u00c0 venir...</p>"},{"location":"parcours/","title":"Parcours d'arbres","text":"<p>D\u00e9finition : Un parcours d'arbre est un type d'algorithme consistant \u00e0 visiter les noeuds d'un arbre en suivant un certain ordre.</p> <p>Pourquoi parcourir ?</p> <ul> <li>Rechercher si un arbre contient une valeur particuli\u00e8re.</li> <li>Compter les noeuds qui contiennent une valeur donn\u00e9e.</li> <li>etc.</li> </ul> <p>Il existe deux fa\u00e7ons de parcourir un arbre :</p> <ul> <li>le parcours en profondeur</li> <li>le parcours en largeur</li> </ul> <p>Voici un arbre binaire que l'on souhaite parcourir :</p>"},{"location":"parcours/#le-parcours-en-largeur-dabord","title":"Le parcours en largeur d'abord","text":"<p>Le parcours en largeur consiste \u00e0 parcourir l'arbre niveau par niveau. Le noeud de niveau (ou profondeur) 0 (ou 1 selon la convention choisie pour la profondeur), c'est-\u00e0-dire le noeud racine, est d'abord parcouru, puis les noeuds de niveau 1 (ou 2), et ainsi de suite. \u00c0 chaque niveau, les noeuds sont parcourus de gauche \u00e0 droite.</p> <p>Note : On peut parler de parcours en largeur \"d'abord\", car m\u00eame si le parcours est d'abord effectu\u00e9 en largeur, l'arbre est bien s\u00fbr ensuite visit\u00e9 en profondeur (on visite les noeuds d'un niveau de l'arbre, puis on passe au niveau suivant, etc.)</p> <p>Sur l'arbre ci-dessous : <code>[E, B, G, A, D, F, H, C]</code></p>"},{"location":"parcours/#deroulement-du-parcours-en-largeur","title":"D\u00e9roulement du parcours en largeur","text":"<p>Initialement, on a deux listes : <code>\u00e0 visiter = [E]</code> <code>visit\u00e9s = []</code></p> <p>On visite E (on le retire de la liste des noeuds \u00e0 visiter et on l'ajoute dans celle des noeuds visit\u00e9s), puis on ajoute ses noeuds fils (d'abord gauche, puis droit) \u00e0 la fin des noeuds \u00e0 visiter. <code>\u00e0 visiter = [B, G]</code> <code>visit\u00e9s = [E]</code></p> <p>On visite le premier noeud B de la liste <code>\u00e0 visiter</code> (on l'ajoute \u00e0 la fin de la liste des noeuds visit\u00e9s), puis on ajoute ses noeuds fils \u00e0 la fin de la liste des noeuds \u00e0 visiter : <code>\u00e0 visiter = [G, A, D]</code> <code>visit\u00e9s = [E, B]</code></p> <p>On continue avec le noeud G : <code>\u00e0 visiter = [A, D, F, H]</code> <code>visit\u00e9s = [E, B, G]</code></p> <p>On continue avec le noeud A (qui n'a pas de fils, donc on ajoute rien dans les noeuds \u00e0 visiter) : <code>\u00e0 visiter = [D, F, H]</code> <code>visit\u00e9s = [E, B, G, A]</code></p> <p>Et ainsi de suite... <code>\u00e0 visiter = [F, H, C]</code> <code>visit\u00e9s = [E, B, G, A, D]</code></p> <p><code>\u00e0 visiter = [H, C]</code> <code>visit\u00e9s = [E, B, G, A, D, F]</code></p> <p><code>\u00e0 visiter = [C]</code> <code>visit\u00e9s = [E, B, G, A, D, F, H]</code></p> <p><code>\u00e0 visiter = []</code> <code>visit\u00e9s = [E, B, G, A, D, F, H, C]</code></p>  <p>Note</p> <p>Les premiers noeuds ajout\u00e9s dans <code>\u00e0 visiter</code> sont les premiers noeuds visit\u00e9s. Si l'on impl\u00e9mentait cet algorithme, on pourrait donc utiliser une structure de file, car on ajoute les noeuds \u00e0 la fin, et on les retire au d\u00e9but.</p>"},{"location":"parcours/#le-parcours-en-profondeur-dabord","title":"Le parcours en profondeur d'abord","text":"<p>Le parcours en profondeur d'un arbre est un type de parcours d'arbres qui consiste \u00e0 traiter la racine de l'arbre, et \u00e0 parcourir r\u00e9cursivement les sous-arbres gauche et droit de la racine.</p> <p>Les parcours pr\u00e9fixe, infixe et suffixe (\u00e9galement appel\u00e9 postfixe) se distinguent par l'ordre dans lequel sont effectu\u00e9s ces traitements.</p>"},{"location":"parcours/#parcours-prefixe-racine-gauche-droite","title":"Parcours pr\u00e9fixe - (Racine-Gauche-Droite)","text":"<p>Dans le parcours pr\u00e9fixe, la racine est trait\u00e9e avant les appels r\u00e9cursifs sur le sous-arbre gauche, puis sur le sous-arbre droit.</p>  <p>D\u00e9roulement du parcours pr\u00e9fixe</p> <p>Pr\u00e9condition : L\u2019arbre n\u2019est pas vide Le parcours pr\u00e9fixe se d\u00e9roule comme suit :</p> <ol> <li>On <code>visite</code> le noeud racine de l\u2019arbre.</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre gauche (s\u2019il est NON vide).</li> <li>On effectue le <code>parcours pr\u00e9fixe</code> du sous-arbre droit (s\u2019il est NON vide).</li> </ol>  <p>(La fonction <code>visite</code> reste \u00e0 d\u00e9finir, cela pourrait \u00eatre un simple affichage.)</p> <p>Une technique visuelle : En se \"baladant\" autour de l'arbre (ordre de visite des noeuds en pointill\u00e9s), on liste chaque noeud la premi\u00e8re fois qu\u2019on le rencontre dans la balade.</p> <p>Sur l'arbre ci-dessous : <code>[E, B, A, D, C, G, F, H]</code></p>"},{"location":"parcours/#parcours-suffixe-ou-postfixe-gauche-droite-racine","title":"Parcours suffixe ou postfixe - (Gauche-Droite-Racine)","text":"<p>Dans le parcours suffixe (ou postfixe), la racine est trait\u00e9e apr\u00e8s les appels r\u00e9cursifs sur le sous-arbre gauche puis sur le sous-arbre droit.</p>  <p>D\u00e9roulement du parcours suffixe</p> <p>Pr\u00e9condition : L\u2019arbre n\u2019est pas vide Le parcours suffixe se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours suffixe</code> du sous-arbre gauche (s\u2019il est NON vide).</li> <li>On effectue le <code>parcours suffixe</code> du sous-arbre droit (s\u2019il est NON vide).</li> <li>On <code>visite</code> le noeud racine de l\u2019arbre.</li> </ol>  <p>Une technique visuelle : En se \"baladant\" autour de l'arbre, on liste chaque noeud la derni\u00e8re fois qu\u2019on le rencontre dans la balade.</p> <p>Sur l'arbre ci-dessous : <code>[A, C, D, B, F, H, G, E]</code></p>"},{"location":"parcours/#parcours-infixe-gauche-racine-droite","title":"Parcours infixe - (Gauche-Racine-Droite)","text":"<p>Dans le parcours infixe, le traitement de la racine est effectu\u00e9 entre les appels sur les sous-arbres gauche et droit.</p>  <p>D\u00e9roulement du parcours infixe</p> <p>Pr\u00e9condition : L\u2019arbre n\u2019est pas vide Le parcours infixe se d\u00e9roule comme suit :</p> <ol> <li>On effectue le <code>parcours infixe</code> du sous-arbre gauche (s\u2019il est NON vide).</li> <li>On <code>visite</code> le noeud racine de l\u2019arbre.</li> <li>On effectue le <code>parcours infixe</code> du sous-arbre droit (s\u2019il est NON vide).</li> </ol>  <p>Une technique visuelle : En se \"baladant\" autour de l'arbre, on liste chaque noeud ayant un fils gauche la seconde fois qu\u2019on le voit et chaque noeud sans fils gauche la premi\u00e8re fois qu\u2019on le voit.</p> <p>Sur l'arbre ci-dessous : <code>[A, B, C, D, E, F, G, H]</code></p>"},{"location":"parcours/#autre-methode","title":"Autre m\u00e9thode","text":"<p>On peut \u00e9galement retrouver visuellement les trois parcours pr\u00e9fixe, infixe et postfixe en ajoutant les sous-arbres vides (et ar\u00eates associ\u00e9es) au dessin d'un arbre binaire. Si on trace \u00e0 pr\u00e9sent le contour de l'arbre :</p> <ul> <li>l'ordre pr\u00e9fixe est obtenu en listant les noeuds lorsque l'on passe \u00e0 leur gauche,</li> <li>l'ordre suffixe est obtenu en listant les noeuds lorsque l'on passe \u00e0 leur droite,</li> <li>l'ordre infixe est obtenu en listant les noeuds lorsque l'on passe en dessous.</li> </ul> <p>Pour vous entra\u00eener : voir cette fiche d'exercices.</p>"},{"location":"type_abstrait/","title":"Type abstrait Arbre binaire","text":"<p>Nous avons vu ce qu'\u00e9tait un arbre binaire, ainsi que le vocabulaire g\u00e9n\u00e9ral et les diff\u00e9rentes mesures sur les arbres.</p> <p>Avant de passer \u00e0 la partie impl\u00e9mentation, proposons une interface minimale du type abstrait <code>Arbre</code>.</p>  <p>Note</p> <p>Dans toute la suite du cours, on utilisera le type <code>Arbre</code> pour d\u00e9signer un arbre binaire.</p>  <p>On rappelle qu'un arbre binaire est soit :</p> <ul> <li>un arbre vide</li> <li>un arbre caract\u00e9ris\u00e9 par un noeud racine, un sous-arbre gauche et un sous-arbre droit, eux-m\u00eames \u00e9tant des arbres binaires.</li> </ul>  <p>Type abstrait Arbre</p> <p>Utilise : Noeud, Element, Bool Op\u00e9rations : \\(nvABV :~\\rightarrow Arbre\\) \\(nvAB :~Noeud \\times Arbre \\times Arbre \\rightarrow  Arbre\\) \\(racine :~Arbre \\rightarrow Noeud\\) \\(gauche :~Arbre \\rightarrow Arbre\\) \\(droite :~Arbre \\rightarrow Arbre\\) \\(contenu :~Noeud \\rightarrow Element\\) \\(est\\_vide :~Arbre \\rightarrow Bool\\) Pr\u00e9conditions (\\(a\\) : Arbre) : \\(racine(a)\\) est d\u00e9fini si et seulement si \\(\\neg est\\_vide(a)\\) \\(gauche(a)\\) est d\u00e9fini si et seulement si \\(\\neg est\\_vide(a)\\) \\(droite(a)\\) est d\u00e9fini si et seulement si \\(\\neg est\\_vide(a)\\)</p>"},{"location":"vocabulaire/","title":"Arbres : d\u00e9finitions et vocabulaire","text":""},{"location":"vocabulaire/#une-structure-hierarchique","title":"Une structure hi\u00e9rarchique ?","text":"<p>Exemple : La hi\u00e9rarchie (organigramme) d'une entreprise :</p>"},{"location":"vocabulaire/#les-arbres-pour-quoi-faire","title":"Les arbres, pour quoi faire ?","text":"<p>Exemple 1 : Lorsque l'interpr\u00e9teur Python lit un programme, il cr\u00e9e d'abord un arbre syntaxique utilisant la grammaire du langage. On ne pourrait en effet pas stocker ces donn\u00e9es dans une structure lin\u00e9aire sans y perdre la structuration du programme.</p> <pre><code>def produit(a: int, b: int) -&gt; int:\n    s = 0\n    for i in range(b):\n        s = s + a\n    return s\n</code></pre>  <p>Exemple 2 : Arbre d'une page HTML</p> <p><pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\"&gt;\n        &lt;title&gt;Ma superbe page&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Mon super titre&lt;/h1&gt;\n        &lt;p&gt;Mon super paragraphe&lt;/p&gt;\n        &lt;img src=\"mon_image.png\" alt=\"ma superbe image\" /&gt;\n    &lt;/body&gt;\n    &lt;footer&gt;\n        &lt;p&gt;Un pied de page&lt;/p&gt;\n    &lt;/footer&gt;\n&lt;/html&gt;\n</code></pre> </p> <p>Exemple 3 : Arborescence des fichiers sur Linux Source : pixees</p>"},{"location":"vocabulaire/#les-arbres","title":"Les arbres","text":""},{"location":"vocabulaire/#definition","title":"D\u00e9finition","text":"<p>Arbre : ensemble de noeuds organis\u00e9s de fa\u00e7on hi\u00e9rarchique \u00e0 partir d'un noeud appel\u00e9 racine.</p> <p>Un arbre est une structure de donn\u00e9es :</p> <ul> <li>hi\u00e9rarchique</li> <li>naturellement r\u00e9cursive</li> </ul>"},{"location":"vocabulaire/#vocabulaire","title":"Vocabulaire","text":"<ul> <li>Un noeud est caract\u00e9ris\u00e9 par :<ul> <li>une \u00e9tiquette (= valeur ou cl\u00e9 associ\u00e9e au noeud) si l'arbre est \u00e9tiquet\u00e9,</li> <li>un nombre fini de fils.</li> </ul> </li> <li>Le noeud initial est appel\u00e9 racine de l'arbre.</li> <li>Un noeud :<ul> <li>est reli\u00e9 \u00e0 un noeud p\u00e8re par une ar\u00eate (parfois appel\u00e9e branche) SAUF le noeud racine.</li> <li>peut avoir une ou plusieurs ar\u00eates sortantes le reliant \u00e0 ses noeuds fils.</li> <li>est appel\u00e9 feuille s'il n'a pas de fils.</li> </ul> </li> </ul>  <ul> <li>chemin - deux conventions :<ul> <li>suite de noeuds cons\u00e9cutifs de l'arbre, de longueur \u00e9gale au nombre de noeuds du chemin. Sur l'arbre suivant, un chemin allant de A \u00e0 H serait <code>[A, C, E, H]</code> (longueur du chemin : 4). OU</li> <li>suite d'ar\u00eates cons\u00e9cutives de l'arbre, de longueur \u00e9gale au nombre d'ar\u00eates du chemin.Sur l'arbre suivant, un chemin allant de A \u00e0 H serait <code>[A-&gt;C, C-&gt;E, E-&gt;H]</code> (longueur du chemin : 3).</li> </ul> </li> </ul>"},{"location":"vocabulaire/#quelques-mesures-sur-les-arbres","title":"Quelques mesures sur les arbres","text":"<ul> <li> <p>taille d'un arbre : nombre de noeuds de l\u2019arbreL'arbre ci-dessous a une taille de 8 (car 8 noeuds).</p> </li> <li> <p>profondeur d\u2019un noeud - deux conventions :</p> <ul> <li>nombre de noeuds rencontr\u00e9s pour aller de la racine jusqu'\u00e0 ce noeudSur l'arbre ci-dessous, la profondeur du noeud H est de 4. OU</li> <li>nombre d\u2019ar\u00eates rencontr\u00e9es pour aller de la racine jusqu'\u00e0 ce noeudSur l'arbre ci-dessous, la profondeur du noeud H est de 3.</li> </ul> </li> <li> <p>hauteur d\u2019un arbre : deux conventions :</p> <ul> <li>profondeur maximale des feuilles de l\u2019arbre (d\u00e9pend de la convention choisie pour la profondeur.)Sur l'arbre ci-dessous, la hauteur de l'arbre est la profondeur du noeud H, elle est donc de 4 ou de 3 selon la convention choisie.</li> </ul> </li> <li> <p>arit\u00e9/degr\u00e9 d\u2019un noeud : nombre de fils du noeud.</p> </li> <li> <p>arit\u00e9/degr\u00e9 d\u2019un arbre : nombre maximal de fils des noeuds de l\u2019arbre.</p> </li> </ul>"},{"location":"vocabulaire/#les-arbres-binaires","title":"Les arbres binaires","text":""},{"location":"vocabulaire/#definition_1","title":"D\u00e9finition","text":"<p>Un arbre binaire est : - soit un arbre vide, qui ne contient aucun noeud, - soit un arbre poss\u00e9dant un noeud, appel\u00e9 la racine de l'arbre, reli\u00e9 \u00e0 exactement deux arbres binaires, respectivement appel\u00e9s sous-arbre gauche et sous-arbre droit (pouvant \u00eatre vides).</p> <p>La racine d'un arbre binaire est reli\u00e9e \u00e0 la racine du sous-arbre gauche et \u00e0 la racine du sous-arbre droit (lorsqu'ils ne sont pas vides).</p> <p>Un arbre binaire poss\u00e8de les particularit\u00e9s suivantes qui le distinguent d'un arbre enracin\u00e9 :</p> <ul> <li>Il peut \u00eatre un arbre vide</li> <li>Il poss\u00e8de TOUJOURS deux sous-arbres (qui peuvent \u00eatre vides ou mener au noeud racine du sous-arbre)</li> <li>La racine d'un arbre binaire poss\u00e8de 0, 1 ou 2 noeuds fils.</li> <li>Le placement des \u00e9l\u00e9ments \u00e0 gauche ou \u00e0 droite doit suivre une logique interne et n'est pas al\u00e9atoire.</li> </ul>"},{"location":"vocabulaire/#arbres-binaires-particuliers","title":"Arbres binaires particuliers","text":"<p>Source : http://pascal.delahaye1.free.fr/cpge/informatique/cours%20projetes/cp08.pdf</p>  <ul> <li> <p>Un arbre binaire filiforme (ou d\u00e9g\u00e9n\u00e9r\u00e9) est un arbre dans lequel tous les noeuds internes n\u2019ont qu\u2019un seul fils. (Un arbre filiforme ne poss\u00e8de donc qu\u2019une seule feuille.)</p> </li> <li> <p>Un arbre binaire localement complet (ou arbre binaire strict) est un arbre binaire dont tous les noeuds internes poss\u00e8dent exactement z\u00e9ro ou deux fils (l'arbre vide n'est pas localement complet).</p> </li> <li> <p>Un peigne gauche (respectivement peigne droit) est un arbre binaire localement complet dans lequel tout fils droit (respectivement gauche) est une feuille.</p> </li> <li> <p>Un arbre binaire parfait est un arbre binaire localement complet dans lequel tous les niveaux sont remplis (toutes les feuilles sont \u00e0 la m\u00eame profondeur).</p> </li> <li> <p>Un arbre binaire complet (ou presque complet) est un arbre binaire dans lequel tous les niveaux sont remplis \u00e0 l\u2019exception \u00e9ventuelle du dernier, auquel cas les feuilles du dernier niveau sont align\u00e9es \u00e0 gauche.</p> </li> <li> <p>Un arbre binaire \u00e9quilibr\u00e9 est un arbre binaire tel que pour chaque noeud, le sous-arbre gauche et le sous-arbre droit ont une hauteur qui ne diff\u00e8re que de 1 au plus.</p> </li> </ul>"},{"location":"vocabulaire/#relations-entre-taille-n-et-hauteur-h","title":"Relations entre taille n et hauteur h","text":""},{"location":"vocabulaire/#encadrement-avec-une-profondeur-0-pour-la-racine","title":"Encadrement avec une profondeur 0 pour la racine\u00a0:","text":"<ul> <li>Pour une taille n donn\u00e9e : \\(\\lfloor log_{2}(n) \\rfloor \\leq h \\leq n-1\\)<ul> <li>h est minimale lorsque l'arbre est complet (ou parfait), h est maximale lorsque l'arbre est filiforme</li> <li>exemple si \\(n=12\\) : \\(3 \\leq h \\leq 11\\)</li> </ul> </li> <li>Pour une hauteur h donn\u00e9e : \\(h+1 \\leq n \\leq 2^{h+1}-1\\)<ul> <li>n est minimale lorsque l'arbre est filiforme, n est maximale lorsque l'arbre est parfait</li> <li>exemple si \\(h=5\\) : \\(6 \\leq h \\leq 63\\)</li> </ul> </li> </ul>"},{"location":"vocabulaire/#encadrement-avec-une-profondeur-1-pour-la-racine","title":"Encadrement avec une profondeur 1 pour la racine\u00a0:","text":"<ul> <li>Pour une taille n donn\u00e9e : \\(\\lceil log_{2}(n+1) \\rceil \\leq h \\leq n\\)<ul> <li>h est minimale lorsque l'arbre est complet (ou parfait), h est maximale lorsque l'arbre est filiforme</li> <li>exemple si \\(n=12\\) : \\(4 \\leq h \\leq 12\\)</li> </ul> </li> <li>Pour une hauteur h donn\u00e9e : \\(h \\leq n \\leq 2^{h}-1\\)<ul> <li>n est minimale lorsque l'arbre est filiforme, n est maximale lorsque l'arbre est parfait</li> <li>exemple si \\(h=5\\) : \\(5 \\leq h \\leq 31\\)</li> </ul> </li> </ul>"}]}